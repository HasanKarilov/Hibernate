Hibernate
===============================
    Когда вы слышите что-то, вы забываете это.
    Когда вы видите что-то, вы запоминаете это.
    Но только когда вы начинаете делать это,
    вы начинаете понимать это

    Старинная китайская поговорка

JDBC
===============
JDBC (Java Database Connectivity) – это технология, которая обеспечивает доступ Java API к реляционным базам данных. Благодаря этому, наши Java-приложения могут выполнять SQL-запросы и взаимодействовать с базами данных (далее – БД), котрые поддерживают SQL.

JDBC является крайне гибкой и позволяет нам писать приложения, которые не зависят от конкретной платформы и могут взаимодействовать с различными СУБД без каких либо изменение в программном коде.

**Какие плюсы даёт нам JDBC:**

   -Простая и понятная обработка SQL-запросов
   -Крайне убдобна для небольших приложений

Простой и понятный синтаксис

**Какие минусы JDBC:**

   -Сложно использовать и поддерживать в больших проектах
   -Большое количество кода
   -Сложно реализовывать концепцию MVC.

ORM (Object Relational Mapping)
===============
ORM – это техника программирования, которая служит для того, чтобы обеспечивать преобразование данных при их обмене между реляционной базой данных и (в нашем случае) Java.

Так какие же преимущества нам даёт ORM в сравнение с JDBC?

   -Позволяет нашим бизнес методам обращаться не к БД, а к Java-классам
   -Ускоряет разработку приложения
   -Основан на JDBC
   -Отделяет SQL-запросы от ОО модели
   -Позволяет не думать о реализации БД
   -Сущности основаны на бизнес-задачах, а не на стуктуре БД
   -Управление транзакциями

ORM состоит из:

   -API, который реализует базовые операции (СОЗДАНИЕ, ЧТЕНИЕ,  ИЗМЕНЕНИЕ, УДАЛЕНИЕ) объектов-моделей.
   -Средства настройки метаданных связывания
   -Технику взаимодействия с транзакциями, которая позволяет реализовать такие функции, как dirty checking, lazy association fetching и т.д.

А самыми распрастранёнными ORM фреймворками являются:

   -Hibernate (который мы и будем изучать в этом цикле статей)
   -EJB
   -JDO
   -Spring DAO
   
   
Архитектура
===============
Hibernate – это ORM фреймворк для Java с открытым исходным кодом. Эта технология является крайне мощной и имеет высокие показатели производительности.

Hibernate создаёт связь между таблицами в базе данных (далее – БД) и Java-классами и наоборот. Это избавляет разработчиков от огромного количества лишней, рутинной работы, в которой крайне легко допустить ошибку и крайне трудно потом её найти..
 
 **Transaction**
 
 Этот объект представляет собой рабочую единицу работы с БД. В Hibernate транзакции обрабатываются менеджером транзакций.
 
 **SessionFactory**
 
 Самый важный и самый тяжёлый объект (обычно создаётся в единственном эземпляре, при запуске прилодения). Нам необходима как минимум одна SessionFactory для каждой БД, каждый из которых конфигурируется отдельным конфигурационным файлом.
 
 **Session**
 
 Сессия исползуется для получения физического соединения с БД. Обычно, сессия создаётся при необходимости, а после этого закрывается. Это связано с тем, что эти объекты крайне легковесны. Чтобы понять, что это такое, модно сказать, что создание, чтение, изменение и удаление объектов происходит через объект Session.
 
 **Query**
 
 Этот объект использует HQL или SQL для чтения/записи данных из/в БД. Экземпляр запроса используется для связыания парметров запроса, ограничения количества результатов, которые будут возвращены и для выполнения запроса.
 
 **Configuration**
 
 Этот объект используется для создания объекта SessionFactory и конфигурирует сам Hibernate с помощью конифигурационного XML-файла, который объясняет, как обрабатывать объект Session.
 
 **Criteria**
 
 Используется для создания и выполнения объекто-ориентированных запроса дял получения объектов.
 
Конфигурирование
===============
Для корректной работы, мы должны передать Hibernate подробную информацию, которая связывает наши Java-классы c таблицами в базе данных (далее – БД). Мы, также, должны укзать значения определённых свойств Hibernate.

обычно, вся эта информация помещена в отдельный файл, либо XML-файл – hibernate.cfg.xml, либо – hibernate.properties.

В этой статье мы рассмотрим конфигурирование приложение с помощью XML-файла hibernate.cfg.xml.

Для начала рассмотрим ключевые свойства, которые должны быть настроены в типичном приложении:

hibernate.dialect

Указывает HIebrnate диалект БД. Hibernate, в своб очередь, генерирует необходимые SQL-запросы (например, org.hibernate.dialect.MySQLDialect, если мы используем MySQL).

hibernate.connection-driver_class

Указывает класс JDBC драйвера.

hibernate.connection.url

Указывает URL (ссылку) необходимой нам БД (например, jdbc:mysql://localhost:3306/database).

hibernate.connection.username

Указывает имя пользователя БД (например, root).

hibernate.connection.password

Укащывает пароль к БД (например, password).

hibernate.connection.pool_size

Ограничивает количество соединений, которые находятся в пуле соединений Hibernate.

hibernate.connection.autocommit
Указывает режим autocommit для JDBC-соединения.

Давайте рассмотрим пример конфигурационного XML-файла.

Исходные данные:
Тип БД: MySQL

Имя базы данных: database

Имя пользователя: root

Пароль: password

    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE hibernate-configuration SYSTEM 
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    
    <hibernate-configuration>
       <session-factory>
       <property name="hibernate.dialect">
          org.hibernate.dialect.MySQLDialect
       </property>
       <property name="hibernate.connection.driver_class">
          com.mysql.jdbc.Driver
       </property>
    
       <!-- Assume test is the database name -->
       <property name="hibernate.connection.url">
          jdbc:mysql://localhost/database
       </property>
       <property name="hibernate.connection.username">
          root
       </property>
       <property name="hibernate.connection.password">
          password
       </property>
    
    </session-factory>
    </hibernate-configuration>
    
Сессии
========
Сессия используется для получения физического соединения с базой данных (далее – БД). Благодаря тому, что сессия является легковесны объектом, его создают (открывают сессию) каждый раз, когда возникает необходимость, а потом, когда необходимо, уничтожают (закрывают сессию). Мы создаём, читаем, редактируем и удаляем объекты с помощью сессий.

Мы стараемся создавать сессии при необходимости, а затем уничтожать их из-за того, что ни не являются потоко-защищёнными и не должны юыть открыты в течение длительного времени.

Экземпляр класса может находиться в одном из трёх состояний:

   **transient**
    Это новый экземпляр устойчивого класса, который не привязан к сессии и ещё не представлен в БД. Он не имеет значения, по которому может быть идентифицирован.
   **persistent**
    Мы модем создать преходный экземпляр класса, связав его с сессией. Устойчивый экземпляр класса представлен в БД, а значение идентификатора связано с сессией.
   **detached**
    После того, как сессия закрыта, экземпляр класса становится отдельным, независимым экземпляром класса.

В примитивном виде, транзакция выглядит примерно таким образом:

Session session = sessionFactory.openSession();
Transaction transaction = null;
    
    try{
        transaction = session.beginTransaction();
        
        /**
         * Here we make some work.
         * */
        
        transaction.commit();
    }catch(Exception e){
        if(transaction !=null){
            transaction.rollback();
            e.printStackTrace();
        }
        e.printStackTrace();
    }finally{
        session.close();
    }
    
В этом примере, в случае исключения, происходит откат (rollback).

В интерфейсе Session определены 23 метода, которые мы можем использовать:

_Transaction beginTransaction()_ - Начинает транзакцию и возвращает объект Transaction.

_void cancelQuery()_ - Отменяет выполнение текущего запроса.

_void clear()_ - Полностью очищает сессию

_Connection close()_ - Заканчивает сессию, осовождает JDBC-соединение и выполняет очистку.

_Criteria createCriteria(String entityName)_ - Создание нового экземпляра Criteria для объекта с указанным именем.

_Criteria createCriteria(Class persistentClass)_ - Создание нового экземпляра Criteria для указанного класса.

_Serializable getIdentifier(Object object)_ - Возвращает идентификатор данной сущности, как сущности, связанной с данной сессией.

_void update(String entityName, Object object)_ - Обновляет экземпляр с идентификатором, указанном в аргументе.

_void update(Object object)_ - Обновляет экземпляр с идентификатором, указанном в аргументе.

_void saveOrUpdate(Object object)_ - Созраняет или обновляет указанный экземпляр.

_Serializable save(Object object)_ - Сохраянет экземпляр, предварительно назначив сгенрированный идентификатор.

_boolean isOpen()_ - Проверяет открыта ли сессия.

_boolean isDirty()_ - Проверят, есть ли в данной сессии какие-либо изменения, которые должны быть синхронизованы с базой данных (далее – БД).

_boolean isConnected()_ - Проверяет, подключена ли сессия в данный момент.

_Transaction getTransaction()_ - Получает связанную с этой сессией транзакцию.

_void refresh(Object object)_ - Обновляет состояние экземпляра из БД.

_SessionFactory getSessionFactory()_ - Возвращает фабрику сессий (SessionFactory), которая создала данную сессию.

_Session get(String entityName, Serializable id)_ - Возвращает созранённый экземпляр с указанными именем сущности и идентификатором. Если таких сохранённых экземпляров нет – возвращает null.

_void delete(String entityName, Object object)_ - Удаляет сохранённый экземпляр из БД.

_void delete(Object object)_ - Удаляет сохранённый экземпляр из БД.

_SQLQuery createSQLQuery(String queryString)_ - Создаёт новый экземпляр SQL-запроса (SQLQuery) для данной SQL-строки.

_Query createQuery(String queryString)_ - Создаёт новый экземпляр запроса (Query) для данной HQL-строки.

_Query createFilter(Object collection, String queryString)_ - Создаёт новый экземпляр запроса (Query) для данной коллекции и фильтра-строки.


Сохраняемые классы
==================
Ключевая функция Hibernate заключается в том, что мы можем взять занчения из нашего Java-класса и созранить их в таблице базы данных (далее – БД). С помощью конфигурационных файлов мы указываем Hibernate как извлечь данные из класса и соединить с определённым столбцами в таблице БД.

Если мы хотим, чтобы экземпляры (объекты) Java-класса в будущем созранялся в таблице БД, то мы называем их “сохранямые классы” (persistent class). Для того, чтобы сделать работу с Hibernate аксимально удобной и эффективной, мы следует использовать программную молель Простых Старых Java Объектов (Plain Old Java Object – POJO).

Сущесвуют определённые требования к POJO классам. Вот самые главные из них:

   -Все классы должны иметь ID для простой идентификации наших объектов в БД и в Hibernate. Это поле класса соединяется с первичным ключём (primary key) таблицы БД.
   -Все POJO – классы должны иметь конструктор по умолчанию (пустой).
   -Все поля POJO – классов должны иметь модификатор доступа private иметь набор getter-ов и setter-ов в стиле JavaBean.
   -POJO – классы не должны содержать бизнес-логику.

Мы называем классы POJO для того, чтобы подчеркнуть тот факт, что эти объекты являются экземплярами обычных Java-классов.


Соединяющие файлы
=================
Чаще всего, когда мы имеем дело с ORM фреймворком, связи между объектами и таблицами в базе данных (далее – БД) указываются в XML – файле.
Давайте рассмотрим наш предыдущий POJO – класс Developer.java :

    public class Developer {
        private int id;
        private String firstName;
        private String lastName;
        private String specialty;
        private int experience;
    
        /**
         * Default Constructor
         */
        public Developer() {
        }
    
        /**
         * Plain constructor
         */
        public Developer(int id, String firstName, String lastName, String specialty, int experience) {
            this.id = id;
            this.firstName = firstName;
            this.lastName = lastName;
            this.specialty = specialty;
            this.experience = experience;
        }
    getters & setters
    }
    
Тперь создадим таблицу в БД под названием HIBERNATE_DEVELOPERS:

    CREATE TABLE HIBERNATE_DEVELOPERS(
       ID INT NOT NULL AUTO_INCREMENT,
       FIRST_NAME VARCHAR(50) DEFAULT NULL,
       LAST_NAME VARCHAR(50) DEFAULT NULL,
       SPECIALTY VARCHAR(50) DEFAULT NULL,
       EXPERIENCE INT DEFAULT NULL,
       PRIMARY KEY(ID)
    );

На данный момент у нас есть две независимых друг от друга сущности: POJO – класс Developer.java и таблица в БД HIBERNATE_DEVELOPERS.

Для того, чтобы связать их друг с другом и получить возможность сохранять значения полей класса, нам необходимо объяснить, как именно это делать Hibernate фреймворку.
ЧТобы это сделать, мы создаём конфигурационной XML – файл Developer.hbm.xml
Вот этот файл:


    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE hibernate-mapping PUBLIC
            "-//Hibernate/Hibernate Mapping DTD//EN"
            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
    <hibernate-mapping>
        <class name="net.proselyte.hibernate.pojo.Developer" table="HIBERNATE_DEVELOPERS">
            <meta attribute="class-description">
                This class contains developer's details.
            </meta>
            <id name="id" type="int" column="id">
                <generator class="native"/>
            </id>
            <property name="firstName" column="first_name" type="string"/>
            <property name="lastName" column="last_name" type="string"/>
            <property name="specialty" column="last_name" type="string"/>
            <property name="experience" column="salary" type="int"/>
        </class>
    </hibernate-mapping>
    
На данный момент мы ещё не можем сказать, что наше приложение готово, но у нас есть часть необходимых конфигураций. Давайте разберем их.

   **<hibernate-mapping>**
    Это ключевой тег , который должен быть в каждом XML – фалйе для связывания (mapping). Внутри этого тега мы и конфигурируем наши связи.
    
   **<class>**
    Тег <class> используется для того, чтоы указать связь между POJO – классов и таблицей в БД. Имя класса указывается с помощью свойства name, имя таблицы в БД – с помощью свойства table.
   
   **<meta>**
    Опциональный (необязательный) тег, внутри которого мы можем добавить описание класса.
   
   **<id>**
    Тег <id > связывает уникальный идентификатор ID в POJO – классе и первичный ключ (primary key) в таблице БД. Свойство name соединяет поле класса со свойством column, которое указывает нам колонку в таблице БД. Свойство type определяет тип связывания (mapping) и используется для конфертации типа данных Java в тип данных SQL.
   
   **<generator>**
    Этот тег внутри тега <id> используется для того, что генерировать первичные ключи автоматически. Если мы указываем это свойство native, как в примере, приведённом выше, то Hibernate сам выберет алгоритм (identity, hilo, sequence) в зависимости от возможностей БД.
   
   **<property>**
    Мы используем этот тег для того, чтобы связать (map) конкретное поле POJO – класса с конкретной колонкой в таблице БД. Свойство name указывает поле в классе, в то время как свойство column указывает на колонку в таблице БД. Свойство type указывает тип связывания (mapping) и конвертирует тип данных Java в тип данных SQL.

Существуют также и другие теги, которые могут быть использованы в конфигурационном XML – файле, которые не были указаны в этой теме.

Аннотации.
=========
Во всех предыдущих примерах мы использовали конфигурационные XML – файлы для конфигурирования Hibernate. В этих XML – файлах мы указывали Hibernate с какой таблицей в нешей базе данных (далее – БД) необходимо связать тот или иной POJO – класс и к каким колонкам относятся те или иные поля в этом классе.

Но в Hibernate предусмотрена возможность конфигурирования прилоения с помощью аннотаций.

Аннотации являются мощным иструментом  для предоставления метаданных, а также намного нагляднее при чтении нашего кода другим разработчиком.

Обязательными аннотациями являются следующие:

**@Entity**
Эта аннотация указывает Hibernate, что данный класс является сущностью (entity bean). Такой класс должен иметь конструктор по-умолчанию (пустой конструктор).

**@Table**
С помощью этой аннотации мы говорим Hibernate,  с какой именно таблицей необходимо связать (map) данный класс. Аннотация @Table имеет различные аттрибуты, с помощью которых мы можем указать имя таблицы, каталог, БД и уникальность столбцов в таблец БД.

**@Id**
С помощью аннотации @Id мы указываем первичный ключ (Primary Key) данного класса.

**@GeneratedValue**
Эта аннотация используется вместе с аннотацией @Id и определяет такие паметры, как strategy и generator.

**@Column**
Аннотация @Column определяет к какому столбцу в таблице БД относится конкретное поле класса (аттрибут класса).

Наиболее часто используемые аттрибуты аннотации @Column такие:

   **name**
    Указывает имя столбца в таблице
   **unique**
    Определяет, должно ли быть данноезначение уникальным
   **nullable**
    Определяет, может ли данное поле быть NULL, или нет.
   **length**
    Указывает, какой размер столбца (например колчиство символов, при использовании String).
